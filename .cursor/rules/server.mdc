---
globs: src/server/**
alwaysApply: false
---

## API Design Patterns

### 1. RESTful Endpoints

- Follow REST conventions for CRUD operations
- Use consistent URL patterns
- Implement proper HTTP status codes
- Design module-specific endpoints for complex operations

### 2. Error Handling

- Use consistent error response format
- Include error codes for programmatic handling
- Provide meaningful error messages
- Log errors with proper context

## Security Patterns

### 1. Authentication Middleware

- Protect API routes with authentication checks
- Implement proper session management
- Handle unauthorized access gracefully
- Use secure session storage

### 2. Role-Based Access Control

- Implement role-based permissions
- Check permissions at API level
- Provide clear error messages for forbidden access
- Audit permission changes

## Elysia Framework Best Practices

### 1. Folder Structure

- Use feature-based folder structure where each feature has its own folder
- Each feature folder contains: `index.ts` (Elysia controller), `service.ts` (business logic), `model.ts` (validation schemas)
- Keep related code together in feature modules
- Example structure:
  ```
  src/server/api/
    auth/
      index.ts       (Elysia controller)
      service.ts     (business logic)
      model.ts       (validation schemas)
  ```

**Example:**

```typescript
// auth/index.ts - Controller
import { Elysia } from "elysia";
import { Auth } from "./service";
import { AuthModel } from "./model";

export const auth = new Elysia({ prefix: "/auth" }).get(
  "/sign-in",
  async ({ body, cookie: { session } }) => {
    const response = await Auth.signIn(body);
    session.value = response.token;
    return response;
  },
  {
    body: AuthModel.signInBody,
    response: AuthModel.signInResponse,
  },
);

// auth/service.ts - Service
import { status } from "@/server/helpers/responseWrapper";
import type { AuthModel } from "./model";

// If the class doesn't need to store a property,
// you may use `abstract class` to avoid class allocation
export abstract class Auth {
  static async signIn({ username, password }: AuthModel.signInBody) {
    const user = await sql`
      SELECT password
      FROM users
      WHERE username = ${username}
      LIMIT 1`;

    if (await Bun.password.verify(password, user.password))
      throw status(400, "Invalid username or password" satisfies AuthModel.signInInvalid);

    return {
      username,
      token: await generateAndSaveTokenToDB(user.id),
    };
  }
}

// auth/model.ts - Model
import { z } from "zod";

export namespace AuthModel {
  export const signInBody = z.object({
    username: z.string(),
    password: z.string(),
  });

  export type signInBody = z.infer<typeof signInBody>;

  export const signInResponse = z.object({
    username: z.string(),
    token: z.string(),
  });

  export type signInResponse = z.infer<typeof signInResponse>;

  export const signInInvalid = z.literal("Invalid username or password");
  export type signInInvalid = z.infer<typeof signInInvalid>;
}
```

### 2. Controller Patterns

- **Use Elysia instance as the controller itself** - Each Elysia instance represents one controller
- Extract only needed values from Context using destructuring, never pass entire Context to services
- For reusable request-dependent logic, create Elysia plugins/macros

**✅ Do:**

```typescript
import { Elysia } from "elysia";
import { Service } from "./service";

new Elysia().get("/", ({ stuff }) => {
  return Service.doStuff(stuff);
});
```

### 3. Service Patterns

There are 2 types of services in Elysia:

1. **Non-request dependent services**: Use abstract static classes or standalone functions
   - Decouple business logic from HTTP request handling
   - Keep services pure and testable without Elysia context
   - Use `abstract class` with `static` methods to avoid class allocation when no instance state is needed
   - **Do NOT use Elysia instances for these** - Only use abstract static classes or standalone functions

2. **Request-dependent services**: Implement as Elysia instances/plugins
   - **Only use this approach when the service needs access to request context** (cookies, headers, status, etc.)
   - Use Elysia plugins with `.macro()` for reusable request-dependent logic
   - Provide a unique `name` property to enable plugin deduplication
   - Decorate only request-dependent properties (requestIP, requestTime, session)

- **Never pass entire Context to services** - Extract needed values via destructuring instead
- If absolutely necessary, infer Context type using `InferContext<typeof elysiaInstance>`

**Non-request dependent service:**

```typescript
import { Elysia } from "elysia";
import { z } from "zod";

abstract class Service {
  static fibo(number: number): number {
    if (number < 2) return number;
    return Service.fibo(number - 1) + Service.fibo(number - 2);
  }
}

new Elysia().get(
  "/fibo",
  ({ body }) => {
    return Service.fibo(body);
  },
  {
    body: z.number(),
  },
);
```

**Request-dependent service (ONLY when service needs request context):**

```typescript
import { Elysia } from "elysia";

// ✅ Do - Use Elysia instance ONLY for request-dependent services
const AuthService = new Elysia({ name: "Auth.Service" }).macro({
  isSignIn: {
    resolve({ cookie, status }) {
      if (!cookie.session.value) return status(401);
      return {
        session: cookie.session.value,
      };
    },
  },
});

const UserController = new Elysia().use(AuthService).get("/profile", ({ Auth: { user } }) => user, {
  isSignIn: true,
});
```

**Note:** This Elysia instance approach is **ONLY** for services that need access to request context (cookies, headers, status codes, etc.). For all other business logic, use abstract static classes or standalone functions.

**Decorate only request-dependent properties:**

```typescript
import { Elysia } from "elysia";

new Elysia()
  .decorate("requestIP", ({ request }) => request.headers.get("x-forwarded-for") || request.ip)
  .decorate("requestTime", () => Date.now())
  .decorate("session", ({ cookie }) => cookie.session.value)
  .get("/", ({ requestIP, requestTime, session }) => {
    return { requestIP, requestTime, session };
  });
```

**❌ Don't pass entire Context:**

```typescript
import type { Context } from "elysia";

class AuthService {
  isSignIn({ status, cookie: { session } }: Context) {
    if (session.value) return status(401);
  }
}
```

**✅ Infer Context if absolutely necessary:**

```typescript
import { Elysia, type InferContext } from "elysia";

const setup = new Elysia().state("a", "a").decorate("b", "b");

class AuthService {
  isSignIn({ status, cookie: { session } }: InferContext<typeof setup>) {
    if (session.value) return status(401);
  }
}
```

### 4. Model/Validation Patterns

- **Use Zod validation schemas** (not class instances or interfaces for runtime validation)
- Define models using Zod schema builders
- Extract TypeScript types from schemas using `z.infer<typeof schema>`
- Group related models in a namespace or object for organization
- Optional: Use Elysia model reference system for model injection and auto-completion

**✅ Do:**

```typescript
import { Elysia } from "elysia";
import { z } from "zod";

const customBody = z.object({
  username: z.string(),
  password: z.string(),
});

type CustomBody = z.infer<typeof customBody>;

new Elysia().post(
  "/login",
  ({ body }) => {
    return body;
  },
  {
    body: customBody,
  },
);
```

**❌ Don't use classes or interfaces:**

```typescript
class CustomBody {
  username: string;
  password: string;
  constructor(username: string, password: string) {
    this.username = username;
    this.password = password;
  }
}

interface ICustomBody {
  username: string;
  password: string;
}
```

**Group models:**

```typescript
import { z } from "zod";

export const AuthModel = {
  sign: z.object({
    username: z.string(),
    password: z.string(),
  }),
};
```

**Model injection (optional):**

```typescript
import { Elysia } from "elysia";
import { z } from "zod";

const customBody = z.object({
  username: z.string(),
  password: z.string(),
});

const AuthModel = new Elysia().model({
  "auth.sign": customBody,
});

const UserController = new Elysia({ prefix: "/auth" }).use(AuthModel).post(
  "/sign-in",
  async ({ body, cookie: { session } }) => {
    return true;
  },
  {
    body: "auth.sign",
  },
);
```

### 5. Testing

- Test controllers using `app.handle(new Request('http://localhost/path'))` to directly call handlers with lifecycle
- Keep services decoupled and testable independently from HTTP layer

**Example:**

```typescript
import { Elysia } from "elysia";
import { Service } from "./service";
import { describe, it, expect } from "bun:test";

const app = new Elysia().get("/", ({ stuff }) => {
  Service.doStuff(stuff);
  return "ok";
});

describe("Controller", () => {
  it("should work", async () => {
    const response = await app.handle(new Request("http://localhost/")).then((x) => x.text());

    expect(response).toBe("ok");
  });
});
```
